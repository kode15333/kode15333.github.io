---
title: "운영체제 08"
description: "운영체제 공개강의 8강"
draft: false
template: "post"
category : "cs" 
tags:
  - 운영체제
  - cs
date: 2020-03-12
---
## 메모리관리 - 페이징

## 1. 외부단편화 해결 방법 = 페이징
- 실행파일을 메모리를 동일한 크기로 자르다(프로세스 : 페이징, 메모리 : 프레임)
- 프로세스를 메모리에 올라가면 OS가 페이징 테이블에 해당 프로세스의 주소값을 넣어준다.
- 페이징 테이블은 0부터 시작하는 인덱스이며, 여러 relocation 레지스터의 합
- 논리주소는 페이지번호(논리주소)와 변위(페이지의 크기)로 나뉘어져 페이징 테이블을 거쳐 물리주소로 바뀐다
- 단, 변위(페이지의 크기)는 변하지 않는다.

## 2. 페이징을 하면서 내부단편화 발생
- 프로세스의 크기가 페이지 크기의 배수가 아니면, 마지막 프로세스는 한 프레임을 다 채울수 없다
- 페이지/프레임 크기 : 4 / 프로세스의 크기 : 15 => 4, 4, 4, 3 으로 프레임에 페이지가 쌓임
- 남은공간 = 메모리 낭비
- 하지만, 내부 단편화는 미미하기 때문에 별도의 조치를 하지 않음

## 3. 페이지 테이블 만들기
- cpu에 위치
    - 장점 : 빠른 변환 속도
    - 단점 : 많이 만들지 못한다
- 메모리에 위치
    - 장점 : 많이 만들 수 있다.
    - 단점 : 느린 변환 속도
- TLB(Translation Look-aside Buffer) : 별도의 s램으로 칩셋을 만들어 중간의 이점을 가진다.
- TLB가 전체의 페이징 테이블을 가지고 있지못함, 일부분만 가지고 오고 전체는 메모리에 저장

## 4. 페이징 보호 : 해킹 등 방지
- 모든 주소는 페이지 테이블을 경유하므로, 테이블에 READ, WRITE, EXCUTE 비트를 넣어 해당 페이지의 접근 제어 가능
- 만약, 해당 페이지에는 읽기, 실행 권한만 있는데, 수정을 하려고 하려면, 
- 페이징 테이블에서 인터럽터로 CPU로 전달 -> 운영체저 전달 -> 해당 프로세스 제거(메모리상에서)

## 5. 페이지 공유 : 메모리 낭비 방지
- 같은 프로그램을 쓰는 복수 개의 프로세스가 있다면, CODE + DATA + Stack에서 code는 공유 가능
- 단 non-self-modifying = reentrant code = pure code인 경우
- 프로세스의 페이지 테이블 코드 영역이 같은 곳을 가리키케

## 세크먼테이션
1. 정의
    - 프로세스를 논리적(CODE, DATA, Stack)으로 잘라서 메모리에 배치
2. 세그먼트 테이블
    - 세크먼트 테이블을 이용하여 논리주소를 물리주소로 바꾸어준다
    - 세크먼트 테이블은 논리주소를(segment + 변위)를 물리주소로 변경시 limit을 확인하여 해킹 방지(인터럽터 발생시켜 프로세스 종료)
    - 논리주소 (3, 200) => 물리주소 3번째 인덱스의 물리주소 값 + 200 => 최종 주소값
3. 장점
    - 보호와 공유는 페이징 보다 세그먼테이션이 우수한 이유 : 데이터와 코드가 명확한 기준으로 나뉘어져있어, 기준여부가 명확함
    - 예) 4개 페이징으로 나뉘어진 실행파일 1번째 : 코드만, 2번째 : 코드와 데이터, 3번째 : 데이터만, 4번째 : 스택
    - 2번째 페이징에서 명확한 기준으로 나뉘기 어렵다.
4. 단점
    - 외부 단편화 발생!!! 세그먼트의 크기가 고정이 아니라 가변적이어서 메모리가 정리가 안됨
    - 해결법 : 세크먼트를 페이징하자 Paged Segmenatation
    - 구조 : 논리주소 => 세그먼트 테이블 => 페이징 테이블 => 물리주소
    - 메모리 효율을 좋으나, 단계가 늘어나 속도가 줄어든다. tradeOff 한쪽이 좋으면 한쪽이 나뻐진다

## 가상메모리
1. 정의 : 물리 메모리의 크기 극복 => 100MB 메인 메모리에 200MB 크기의 프로세스 실행
2. 방법
    - 프로세스 이미지를 모두 메로리에 올릴 필요가 없다.
    - 현재 실행에 필요한 부분만 메모리만 올린다.
    - 동적 로딩과 비슷한 개념
3. Demand Paging
    - 전체 프로세스 이미지(페이지들의 집합)는 backing store에 저장
    - 요구되는 페이지만 메모리에 올린다.
4. 하드웨어 지원
    - valid 비트가 추가된 페이지 테이블(현재 메모리상에 페이지가 올라와져있나)
    - valid가 참일 경우 : 논리 주소 => 페이징 테이블 => 물리주소
    - valid가 거짓을 경우 : 논리주소 => 페이징 테이블 => 인터럽터 발생 => OS가 해당 페이징 load => 페이징 테이블에 주소 변경/valid 변경
    - cpu가 변경된 페이징 테이블을 통해 새롭게 로딩된 페이지를 통해 프로그램 실행
5. pure demand paging
    - 정말로 필요한 페이지만 메모리에 로드 시킨다
    - 단점 : 아무것도 없다 => 결국 page falut 다수 발생 => 속도가 느리다
    - 장점 : 효율적인 메모리 사용
6. prepaging
    - 필요할것 같은 페이지는 미리 로딩
    - 단점 : 필요없을수도 있다 => 메모리 효율 감소
    - 장점 : 초기 속도가 빠르다.
7. swapping vs demand paging
    - 차이점 : 바뀌는 단위가 프로세스 vs 페이지
