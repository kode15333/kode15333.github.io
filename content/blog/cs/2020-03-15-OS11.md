---
title: "운영체제 11"
description: "운영체제 공개강의 11강"
draft: false
template: "post"
category : "cs" 
tags:
  - 운영체제
  - cs
date: 2020-03-14
---

## 디스크 스케줄링
![디스크](https://i.stack.imgur.com/ADjBr.gif)
- 디스크 접근 시간
    - Seek time + rotation delay + transfer time
    - SEEK time이 제일 길다
- 다중 프로그래밍 환경
    - 메모리 상에 여러개의 프로세스가 존재하고 그러한 프로세스들은 디스크에서 파일을 읽어옴
    - 디스크에 접근하기 위해서 디스크큐로 넘어가 요청을 대기
- 어떻게 하면 이러한 디스크 큐를 효과적으로 처리할까?
    - track의 위치가 계속해서 다른다면, 디스크헤드가 움직여야하는데(시간 많이 걸림)

## 1. 디스크 스케줄링 알고리즘
1. FCFS(First-Come First-Served)
- Queue처럼 먼저 온 잡에 대해서 처리를 한다
- 가장 간단, 공평 But 효율이 안 좋다

2. SSTF
- 들어온 잡을 기준으로 가장 가까운 곳에 위치한 잡을 처리한다
- 디스크 헤드의 이동을 최소화
- 문제점
    - 만약, 계속해서 프로세스가 유입되면, 멀리 있는 섹터를 못 읽는다(기아상태)
    - 최적의 알고리즘은 아님

3. SCAN
- 헤드를 현재위치에서 기준방향을 잡아서 움직인다.
    - (시작) 현재 50 -> 0 -> 끝 
    - (끝) 현재 50 -> 끝 -> 0
    - C-SCAN
        - 전체적으로 디스크 큐를 처리하기 위해 일자로 표현된다.
        - (시작) 현재 50 -> 0 -(단순이동)-> 끝 -> 현재 
        - (끝) 현재 50 -> 끝 -(단순이동)-> 0 -> 현재
    - LOOK
        - SCAN은 무조건 처음과 끝을 찍고 방향을 튼다
        - LOOK알고리즘은 진행 방향의 마지막 디스크 잡만 처리하고 방향을 튼다.
    - C-LOCK
        - LOOK + C-SCAN
        - 전체적으로 디스크를 처리하기 위해 사용됨
- Elevator alogirithm이라고 한다
    - 내려갈떄 타면, 내려가는 사람이 먼저, 올라갈때 타면 올라가는 사람이 먼저
