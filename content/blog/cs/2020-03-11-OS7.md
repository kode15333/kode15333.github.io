---
title: "운영체제 07"
description: "운영체제 공개강의 7강"
draft: false
template: "post"
category : "cs" 
tags:
  - 운영체제
  - cs
date: 2020-03-11
---
## 메인 메모리 관리

## 1. 운영체제에 중요한 2가지
- 프로세스 관리
- 메모리 관리
    - 메모리를 효과적으로 사용하는 방법 : 1) 메모리 낭비 없애기 2) 가상 메모리

## 2. 메모리 구조
- cpu가 os에게 난 10번지의 메모리를 읽을거야 : 주소 address
- os는 10번지의 데이터를 보내준다 : 데이터 data
- cpu는 계산결과를 다시 10번지로 보내준다 : 데이터버스의 양방향성
- 메모리는 주소 + 데이터로 구성되어있다.

## 3. 프로그램 단계
1. 원천파일 : 자바나 C 같은 고급언어로 만든 파일
2. 컴파일러 / 어셈블러를 통해 원천파일을 목적파일로 변경
3. 링커 : 데이터베이스에 있는 라이브러리를 가져오는 것이나, 다른 목적파일을 하나로 합치는 것
4. 실행파일 : 링커를 통해 만들어진 결과물(.exe)
5. 로더 : 실행파일(메인함수)를 메모리에 올리는 작업 (OS를 올리는것 부팅)

## 4. 프로그램 실행시 구조
- 구조 : code + data + stack
- code : 우리가 짠 코드 (A와 B중 누가 더 커)
- data : 값(A, B)
- stack : 함수 호출했을때 돌아오는 주소

## 5. 프로그램을 메모리에 올리기
- 항상 동일한 메모리 주소값에 같은 프로세스를 실행시킬 수 없다. 
- MMU(memory management unit) 사용 : 재배치 레지스터를 사용(cpu는 0번지를 바라보고 있지만,OS에서 relocation 레지스터에 실제로 올라온 주소의 값으로 변경)
- mmu : base + limit + relocation 레지스터
- cpu가 바라보는 주소 : 논리주소
- mmu의 relocation레지스터를 통해 변경된 주소 : 물리주소(메모리의 실제 주소)

## 메모리 낭비 방지

## 1. 동적 적재
- 프로그램 실행에 반드시 필요한 루틴/데이터만 적재
- 실행시 필요하면 그때 해당 부분을 메모리에 올린다((함수(루틴) : 오류처리, 데이터 : 배열)

## 2. 동적 연결
- 링커를 실행파일 만들기전 실행하기 전 하는것이 아니라(정적 연결), 실행파일이 실행이 되고 링커(동적 연결)
- 여러 프로그램에서 공통 사용되는 라이브러리를 메모리를 중복으로 올리는것을 방지
- 공통으로 사용되는 라이브러리를 메모리를 별도로 올려 실행 중 필요하면 링킹

## 3. 스와핑
- 메모리에 적재되어 있으나, 현재 사용되지 않고 잇는 프로세스 이미지
- 하드디스크에 별도의 공간을 만들어 스와핑된 이미지를 저장함(backing store / swap device , 크기는 메모리의 크키 만큼(OS 제외))
- 하드디스크에 저장되고 있는 실행파일과 스와핑된 실행파일(데이터가 변경되어있을수도 있다.)은 다르다.
- swap-out된 실행파일이 swap-in이 되면 메모리주소가 바뀌므로 OS가 mmu relocation 레지스터의 주소값을 변경

## 연속 메모리 할당

## 1. 메모리의 상태
- 부팅 직후 : OS + big single hole(비워 있는 상태)
- 프로세스 생성 및 종료 반복 : 산발된 메모리의 상태(부분 부분 비워져 있는 상태)
- 메모리의 단편화
    - hole들이 불연속하게 흩어져 있기 때문에 프로세스 적재 불가능
    - 외부 단편화 발생(사용안되는 메모리 부분 발생)

## 2. 초기 메모리 단편화 해결 방법 
- First-fit (최초 적합) : 낮은 주소부터 찾아서 빈곳을 찾아 실행
    - 장점 : 속도 및 메모리 이용률
- Best-fit (최적 적합) : hole의 크기를 비교해서 가장 적합한 크기에서 실행
    - 장점 : 메모리 이용률
- Worst-fit (최악 적합) : 최적 적합이랑 반대 (hole의 크기와 가장 안 맞는 곳)
- Compaction : 흩어져 있는 hole들을 한곳으로 모은다
    - 단점 : 최적 알고리즘 없음, 고부담

## 3. Paging - 페이징 
- 프로세스를 일정한 크기로 자른다 => 페이지
- 메모리를 일정한 크기로 자른다(프로세스를 자른 크기와 동일) => 프레임
- 연속되게 보이기 위해 CPU를 속여야 한다! HOW mmu relocation 레지스터를 여러개를 달아주자 => 페이지 테이블
- mmu : base + limit + relocation + relocation + relocation+.... => base + limit + page table
- 페이징을 통해 외부단편화 해결 => 메모리 100% 사용

## 4. 페이징 주소변환
- 논리주소 : p : 메모리 주소 , d : 페이징/프레임 크기
- 페이지 테이블에서 메모지 주소를 변경해서 논리주소가 물리주소로 변경(단, d는 변하지 않는다.)
-![주소변환](https://2.bp.blogspot.com/-eP3hp95aKQ0/WRcXxlI-ilI/AAAAAAAABRQ/LTsK72INkuEpxpUPLY9Y3bJtjScM1Jc1gCLcB/s1600/segmentation.png)
