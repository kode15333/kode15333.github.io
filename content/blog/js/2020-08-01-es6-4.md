---
title:  "코드스피치 강의 ES6+ 4회차 정리"
description: "코드스피치 강의 ES6+ 4회차 정리"
draft: false
template: "post"
category : "js"
tags:
  - js
date: 2020-08-01
---

## Generator
  1. 정의
      - function *  : Generator 리터럴 
      - Generator를 호출하면 Iterator 객체가 나온다(Iterator이면서 Iteratable한 객체를 반환)
          - for of 뒤에는 Iteratable한 객체가 와야하기 때문에 generator는 올 수 없다.
      - yield를 사용하면 next()룰 호출한것 처럼 value를 리턴한다(이러한 것을 서스펜스)
          - generator 함수에서 yield를 통해 나오면 done : false, generator 함수가 끝나면 done : true
          - 서스펜션이 일어나면서 Iterator result object를 반환 === next()
          - 서스펜션 : Statement은 중간에 멈출수 없는데 Statement을 멈추는 것을 서스펜션
      - Coroutine(코루틴)의 형태
          - 실행 후 중간에 멈춰서 나가고 다시 들어와서 반복적으로 실행
          - 여러번 진입하고(진입 위치가 달라진다 여러번 반환한다) 들어올때 중간부터 들어올수 잇다
          - Roution : 처음부터 들어가서 문 전체를 실행시키는 것 == 함수
 
  2. Iteratable과 차이(객체 상태에 대한 관리요소) 
      - Iteratable
          - 스코프를 이용하여 자유변수를 사용하던지 인스턴스로 만들어서 필드로 관리
      - Generator
          - 지역변수와 매개변수로 관리한다.



      ```js
      function*(max){
        let cursor = 0;
        
        while(cursor < max){
          yield cursor * cursor;cursor++;
        }
      };
      ```

<!-- ##    
이터레이너터에서는 제어문(for / while) 까지 중단 => 제네레이터 서스펜션

추상화 루프
객체안에 루프안에 상태를 보관할테니까 알아서 실행만 하면 알아서 루프가 될거야
그 푸프 개념에 대한 개념을  더욱더 추상화하면 객체가 된다

루프
1. 이터레이션 - 똑같은 행위를 반복
2. 리컬시브 - 똑같은 행위를 반복할수 없고 반복하면서 행위를 평가

모던브라우저에서는 무조건 이터러블 객체만을 받는다(리턴은 this 안에 이터레이터 객체가 있다.) 반드시 구현해야 한다
{
  [Symbol.iterator](){return this},
  data: [ {a : [1,2,3,4] , b : '-'}, [5,6,7], 8, 9]],
  next(){
    let v;
    return
    }
}

알고리즘  : 상태와 제어문을 통해 원하는 값을 얻는것 -->
